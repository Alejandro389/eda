<section data-transition="convex">

    <section data-state="darken" data-menu-title="Quicksort" data-background="images/quicksort-background.jpg">
        <div class="credit white">Imagen: <a href="https://ctcgulf.com/product/recruitment-and-selection">CTC</a></div>
        <h2>Quicksort</h2>
        <h4>Ordenamiento rápido</h4>
    </section>

    <section>
        <h3>Ideas</h3>
        <p>1. Es más rápido ordenar dos listas pequeñas que una grande.</p>
        <p>2. Una lista está ordenada cuando todos los elementos más pequeños de uno dado están a la izquierda de todos los elementos mayores (para cada elemento).</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>1. Caso general: elegir un pivote y agrupar los elementos mayores a un lado y los menores al otro.</p>
        <img width="400px" src="slides/algoritmos/sort-quicksort-general.dot.png"></img>
        <p>Además, el pivote ya está en su posición final</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>2. Ordenar una <span class="blue">lista de 0 o 1 elementos</span> es trivial (ya está ordenada)</p>
        <img width="200px" src="slides/algoritmos/sort-quicksort-base.dot.png"></img>
    </section>

    <section>
        <h3>Algoritmo recursivo</h3>
        <p><code>quick_sort</code>: dado un vector con <code>n</code> elementos, elijo un pivote y agrupo los elementos mayores a un lado y los menores al otro, repito <code>quick_sort</code> sobre cada una de las partes.</p>
        <div class="footnote">Ej.: <a href="https://www.youtube.com/watch?v=ywWBy6J5gz8">Quick-sort with Hungarian (Küküllőmenti legényes) folk dance</a>.</div>
    </section>

    <section data-markdown>
        <script type="text/template">
### Implementación


```cpp[8-27]
#include <iostream>
#include <vector>
///hide
void print(const std::vector<int>& elements) {
    for (auto e: elements) {
        std::cout << e << ", ";
    }
    std::cout << std::endl;
}
///unhide

// A function to merge two ordered lists
int partition(std::vector<int>& elements, int left_index, int right_index)
///hide
{
    auto pivot = elements[left_index];
    int i = left_index, j = right_index;

    while(true) {
        while( elements[i] <= pivot && i <= j ) ++i;
        while( elements[j] > pivot ) --j;
        if( i >= j ) break;
        std::swap(elements[i], elements[j]);
    }
    std::swap(elements[left_index], elements[j]);
    return j;
}
///unhide

// Quick-sort algorithm
void quick_sort(std::vector<int>& elements, int left_index, int right_index) {
    ///hide
    std::cout << "quick_sort: ";
    print(elements);
    ///unhide
    // Check for base/trivial case
    if (left_index >= right_index) {
        return;
    }
    else {
        // Compute the pivot
        int pivot_index = partition(elements, left_index, right_index);

        // Apply quick-sort to both sides (pivot is already in place)
        quick_sort(elements, left_index, pivot_index-1);
        quick_sort(elements, pivot_index+1, right_index);
    }
}

int main() {
  std::vector<int> elements{9, 8, 7, 6, 5, 4, 3, 2, 1};
  ///hide
  std::cout << "Initial vector!" << std::endl;
  print(elements);
  std::cout << "---\n";
  ///unhide
  quick_sort(elements, 0, elements.size()-1);
  ///hide
  std::cout << "\nFinal order:\n";
  print(elements);
  std::cout << "---\n";
  ///unhide
}
``` 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
La función para ejecutar la partición


```cpp[4-18]
#include <iostream>
#include <vector>
///hide
void print(const std::vector<int>& elements) {
    for (auto e: elements) {
        std::cout << e << ", ";
    }
    std::cout << std::endl;
}
///unhide

// A function to compute the partition
int partition(std::vector<int>& elements, int left_index, int right_index)
{
    auto pivot = elements[left_index];  // any element works
    int i = left_index, j = right_index;

    while(true) {
        while( elements[i] <= pivot && i <= j ) ++i;
        while( elements[j] > pivot ) --j;
        if( i >= j ) break;
        std::swap(elements[i], elements[j]);
    }
    std::swap(elements[left_index], elements[j]);
    return j;
}


int main() {
  std::vector<int> elements{2, 8, 11, 1, 3};

  ///hide
  std::cout << "elements: ";
  print(elements);
  ///unhide
  auto pivot_index = partition(elements, 0, elements.size()-1);
  ///hide
  std::cout << "Pivot index: " << pivot_index << std::endl;
  std::cout << "paritition: ";
  print(elements);
  ///unhide
}
``` 
        </script>
    </section>

    <section>
        <h3>Complejidad algorítmica</h3>
        <p>Tiempo: depende de la estrategia para elegir el pivote</p>
        <p>Espacio: hay que almacenar los pivotes</p>
        <hr />
        <div class="fragment">
            <p>Tiempo (*): O(n log n)</p>
            <p>Espacio: O(log n)</p>
            <div class="footnote">(*) El peor caso es O(n<sup>2</sup>), puede darse en listas ya ordenadas o con pocos valores diferentes.</div>
        </div>
    </section>
</section>